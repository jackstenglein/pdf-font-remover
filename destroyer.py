
import parser
import write
import runner
from io import StringIO
import re

CHAR_WHITESPACE = 1
CHAR_DELIMITER = 2
CHAR_REGULAR = 3

CONTEXT_NONE = 1
CONTEXT_OBJ = 2
CONTEXT_XREF = 3
CONTEXT_TRAILER = 4

PDF_ELEMENT_COMMENT = 1
PDF_ELEMENT_INDIRECT_OBJECT = 2
PDF_ELEMENT_XREF = 3
PDF_ELEMENT_TRAILER = 4
PDF_ELEMENT_STARTXREF = 5
PDF_ELEMENT_MALFORMED = 6

class FontDestroyer:
    """
    FontDestroyer changes fonts in PDF documents to have a missing ToUnicode table.
    """

    def __init__(self, options={}):
        """
        __init__ constructs the necessary attributes for a new FontDestroyer.
        """
        self.options = options

        self.countComment = 0
        self.countXref = 0
        self.countTrailer = 0
        self.countStartXref = 0
        self.countIndirectObject = 0

        self.verbose = self.options.verbose
        self.extract = self.options.extract
        self.generate = self.options.generate

        if self.options.type == '-':
            self.optionsType = ''
        else:
            self.optionsType = self.options.type

        if self.options.elements:
            self.selectComment = ('c' in elements)
            self.selectXref = ('x' in elements)
            self.selectTrailer = ('t' in elements)
            self.selectStartXref = ('s' in elements)
            self.selectIndirectObject = ('i' in elements)
        else:
            self.selectIndirectObject = True
            if not self.options.search and not self.options.object and not self.options.reference and not self.options.type and not self.options.searchstream and not self.options.key:
                self.selectComment = True
                self.selectXref = True
                self.selectTrailer = True
                self.selectStartXref = True
            if self.options.search or self.options.key or self.options.reference:
                self.selectTrailer = True


    def UpdatePDF(self, document):
        """pdf-parser, use it to parse a PDF document
        """


        global decoders


        decoders = []
        runner.LoadDecoders(self.options.decoders, True)

        oPDFParser = parser.Parser(document, self.verbose, self.extract)
        dicObjectTypes = {}
        # writer = write.Writer("font-output.pdf")
        # savedRoot = ['1', '0', 'R']

    
        # if self.generate:
        #     print('#!/usr/bin/python')
        #     print('')
        #     print('"""')
        #     print('')
        #     print('Program generated by pdf-parser.py by Didier Stevens')
        #     print('https://DidierStevens.com')
        #     print('Use at your own risk')
        #     print('')
        #     print('Input PDF file: %s' % document)
        #     print('')
        #     print('"""')
        #     print('')
        #     print('import mPDF')
        #     print('import sys')
        #     print('')
        #     print('def Main():')
        #     print('    if len(sys.argv) != 2:')
        #     print("        print('Usage: %s pdf-file' % sys.argv[0])")
        #     print('        return')
        #     print('    oPDF = mPDF.cPDF(sys.argv[1])')


        oPDFParserOBJSTM = None
        while True:
            if oPDFParserOBJSTM == None:
                object = oPDFParser.GetObject()
            else:
                object = oPDFParserOBJSTM.GetObject()
                if object == None:
                    oPDFParserOBJSTM = None
                    object = oPDFParser.GetObject()
                
            
            if self.options.objstm and hasattr(object, 'GetType') and runner.EqualCanonical(object.GetType(), '/ObjStm') and object.ContainsStream():
                # parsing objects inside an /ObjStm object by extracting & parsing the stream content to create a synthesized PDF document, that is then itself parsed
                oPDFParseDictionary = runner.cPDFParseDictionary(object.ContainsStream(), self.options.nocanonicalizedoutput)
                numberOfObjects = int(oPDFParseDictionary.Get('/N')[0])
                offsetFirstObject = int(oPDFParseDictionary.Get('/First')[0])
                indexes = list(map(int, runner.C2SIP3(object.Stream())[:offsetFirstObject].strip().split(' ')))
                if len(indexes) % 2 != 0 or len(indexes) / 2 != numberOfObjects:
                    raise Exception('Error in index of /ObjStm stream')
                streamObject = runner.C2SIP3(object.Stream()[offsetFirstObject:])
                synthesizedPDF = ''
                while len(indexes) > 0:
                    objectNumber = indexes[0]
                    offset = indexes[1]
                    indexes = indexes[2:]
                    if len(indexes) >= 2:
                        offsetNextObject = indexes[1]
                    else:
                        offsetNextObject = len(streamObject)
                    synthesizedPDF += '%d 0 obj\n%s\nendobj\n' % (objectNumber, streamObject[offset:offsetNextObject])
                oPDFParserOBJSTM = parser.Parser(StringIO(synthesizedPDF), self.options.verbose, self.options.extract, (object.id, object.version))

            if object == None:
                break

            # Handle writing to PDF file
            # if object.type == PDF_ELEMENT_COMMENT:
            #     writer.writeComment(object)

            # elif object.type == PDF_ELEMENT_TRAILER:
            #     oPDFParseDictionary = runner.cPDFParseDictionary(object.content[1:], self.options.nocanonicalizedoutput)
            #     result = oPDFParseDictionary.Get('/Root')
            #     if result != None:
            #         savedRoot = result
            
            # Handle printing to console
            if object.type == PDF_ELEMENT_COMMENT:
                print('PDF Comment %s' % runner.FormatOutput(object.comment, self.options.raw))
                print('')

            elif object.type == PDF_ELEMENT_XREF and self.selectXref:
                if self.options.debug:
                    print('xref %s' % runner.FormatOutput(object.content, self.options.raw))
                else:
                    print('xref')
                print('')

            elif object.type == PDF_ELEMENT_TRAILER and self.selectTrailer:
                oPDFParseDictionary = runner.cPDFParseDictionary(object.content[1:], self.options.nocanonicalizedoutput)
                if oPDFParseDictionary == None:
                    print('trailer %s' % runner.FormatOutput(object.content, self.options.raw))
                else:
                    print('trailer')
                    oPDFParseDictionary.PrettyPrint('  ')
                print('')
                    

            elif object.type == PDF_ELEMENT_STARTXREF and self.selectStartXref:
                print('startxref %d' % object.index)
                print('')

            elif object.type == PDF_ELEMENT_INDIRECT_OBJECT and self.selectIndirectObject:
                
                if self.options.type:
                    if runner.EqualCanonical(object.GetType(), self.optionsType):
                        runner.PrintObject(object, self.options)

                else:
                    runner.PrintObject(object, self.options)

            # elif object.type == PDF_ELEMENT_MALFORMED:
            #     try:
            #         fExtract = open(self.options.extract, 'wb')
            #         try:
            #             fExtract.write(C2BIP3(object.content))
            #         except:
            #             print('Error writing file %s' % self.options.extract)
            #         fExtract.close()
            #     except:
            #         print('Error writing file %s' % self.options.extract)
            
        # writer.writeXrefAndTrailer(' '.join(savedRoot))

        # if self.options.generate or self.options.generateembedded != 0:
        #     print("    oPDF.xrefAndTrailer('%s')" % ' '.join(savedRoot))
        #     print('')
        #     print("if __name__ == '__main__':")
        #     print('    Main()')
