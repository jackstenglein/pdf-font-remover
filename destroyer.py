
import parser
import write
import runner
from io import StringIO
import re

CHAR_WHITESPACE = 1
CHAR_DELIMITER = 2
CHAR_REGULAR = 3

CONTEXT_NONE = 1
CONTEXT_OBJ = 2
CONTEXT_XREF = 3
CONTEXT_TRAILER = 4

PDF_ELEMENT_COMMENT = 1
PDF_ELEMENT_INDIRECT_OBJECT = 2
PDF_ELEMENT_XREF = 3
PDF_ELEMENT_TRAILER = 4
PDF_ELEMENT_STARTXREF = 5
PDF_ELEMENT_MALFORMED = 6

class FontDestroyer:
    """
    FontDestroyer changes fonts in PDF documents to have a missing ToUnicode table.
    """

    def __init__(self, options={}):
        """
        __init__ constructs the necessary attributes for a new FontDestroyer.
        """
        self.options = options

        self.countComment = 0
        self.countXref = 0
        self.countTrailer = 0
        self.countStartXref = 0
        self.countIndirectObject = 0

        self.verbose = self.options.verbose
        self.extract = self.options.extract
        self.generate = self.options.generate

        if self.options.type == '-':
            self.optionsType = ''
        else:
            self.optionsType = self.options.type

        if self.options.elements:
            self.selectComment = ('c' in elements)
            self.selectXref = ('x' in elements)
            self.selectTrailer = ('t' in elements)
            self.selectStartXref = ('s' in elements)
            self.selectIndirectObject = ('i' in elements)
        else:
            self.selectIndirectObject = True
            if not self.options.search and not self.options.object and not self.options.reference and not self.options.type and not self.options.searchstream and not self.options.key:
                self.selectComment = True
                self.selectXref = True
                self.selectTrailer = True
                self.selectStartXref = True
            if self.options.search or self.options.key or self.options.reference:
                self.selectTrailer = True

    @staticmethod
    def FormatFont(obj):
        # Remove /Encoding {EncodingValue}
        if obj.id == 299:
            print('Object content before formatting: ', obj.content)

        # encoding = (CHAR_DELIMITER, '/Encoding')
        # if encoding in obj.content:
        #     index = obj.content.index(encoding)
        #     obj.content.pop(index)  # Removes '/Encoding'
        #     obj.content.pop(index)  # Removes ' '
        #     obj.content.pop(index)  # Removes {EncodingValue}

        # # Change /Subtype {FontType} to /Subtype /TrueType
        # subtype = (CHAR_DELIMITER, '/Subtype')
        # if subtype in obj.content:
        #     index = obj.content.index(subtype)
        #     obj.content[index + 2] = (CHAR_DELIMITER, '/TrueType')

        # Add /ToUnicode 524 0 R
        emptyToUnicode = [(CHAR_REGULAR, '/ToUnicode'), (CHAR_WHITESPACE, ' '), (CHAR_REGULAR, '524'), (CHAR_WHITESPACE, ' '), (CHAR_REGULAR, '0'), \
            (CHAR_WHITESPACE, ' '), (CHAR_REGULAR, 'R'), (CHAR_WHITESPACE, ' ')]
        for token in emptyToUnicode:
            obj.content.insert(len(obj.content) - 2, token)
        
        if obj.id == 299:
            print('Object content after formatting: ', obj.content)

        return FontDestroyer.FormatOutput(obj.content, True)

    @staticmethod
    def FormatObject(obj):
        if runner.EqualCanonical(obj.GetType(), "/Font"):
            # print("Writing out Font. Content: ", obj.content)
            return FontDestroyer.FormatFont(obj)
        else:
            return FontDestroyer.FormatOutput(obj.content, True)

    @staticmethod
    def FormatOutput(data, raw):
        if raw:
            if type(data) == type([]):
                return ''.join(map(lambda x: x[1], data))
            else:
                return data
        elif sys.version_info[0] > 2:
            return ascii(data)
        else:
            return repr(data)

    


    def UpdatePDF(self, document):
        """pdf-parser, use it to parse a PDF document
        """


        global decoders


        decoders = []
        runner.LoadDecoders(self.options.decoders, True)

        oPDFParser = parser.Parser(document, self.verbose, self.extract)
        dicObjectTypes = {}
        writer = write.Writer("font-output.pdf", FontDestroyer.FormatObject)
        savedRoot = ['1', '0', 'R']

    
        # if self.generate:
        #     print('#!/usr/bin/python')
        #     print('')
        #     print('"""')
        #     print('')
        #     print('Program generated by pdf-parser.py by Didier Stevens')
        #     print('https://DidierStevens.com')
        #     print('Use at your own risk')
        #     print('')
        #     print('Input PDF file: %s' % document)
        #     print('')
        #     print('"""')
        #     print('')
        #     print('import mPDF')
        #     print('import sys')
        #     print('')
        #     print('def Main():')
        #     print('    if len(sys.argv) != 2:')
        #     print("        print('Usage: %s pdf-file' % sys.argv[0])")
        #     print('        return')
        #     print('    oPDF = mPDF.cPDF(sys.argv[1])')


        oPDFParserOBJSTM = None
        while True:
            if oPDFParserOBJSTM == None:
                object = oPDFParser.GetObject()
            else:
                object = oPDFParserOBJSTM.GetObject()
                if object == None:
                    oPDFParserOBJSTM = None
                    object = oPDFParser.GetObject()
                
            
            if self.options.objstm and hasattr(object, 'GetType') and runner.EqualCanonical(object.GetType(), '/ObjStm') and object.ContainsStream():
                # parsing objects inside an /ObjStm object by extracting & parsing the stream content to create a synthesized PDF document, that is then itself parsed
                oPDFParseDictionary = runner.cPDFParseDictionary(object.ContainsStream(), self.options.nocanonicalizedoutput)
                numberOfObjects = int(oPDFParseDictionary.Get('/N')[0])
                offsetFirstObject = int(oPDFParseDictionary.Get('/First')[0])
                indexes = list(map(int, runner.C2SIP3(object.Stream())[:offsetFirstObject].strip().split(' ')))
                if len(indexes) % 2 != 0 or len(indexes) / 2 != numberOfObjects:
                    raise Exception('Error in index of /ObjStm stream')
                streamObject = runner.C2SIP3(object.Stream()[offsetFirstObject:])
                synthesizedPDF = ''
                while len(indexes) > 0:
                    objectNumber = indexes[0]
                    offset = indexes[1]
                    indexes = indexes[2:]
                    if len(indexes) >= 2:
                        offsetNextObject = indexes[1]
                    else:
                        offsetNextObject = len(streamObject)
                    synthesizedPDF += '%d 0 obj\n%s\nendobj\n' % (objectNumber, streamObject[offset:offsetNextObject])
                oPDFParserOBJSTM = parser.Parser(StringIO(synthesizedPDF), self.options.verbose, self.options.extract, (object.id, object.version))

            if object == None:
                break

            # Handle writing to PDF file
            if object.type == PDF_ELEMENT_COMMENT:
                writer.writeComment(object)

            elif object.type == PDF_ELEMENT_TRAILER:
                oPDFParseDictionary = runner.cPDFParseDictionary(object.content[1:], self.options.nocanonicalizedoutput)
                result = oPDFParseDictionary.Get('/Root')
                if result != None:
                    savedRoot = result
            
            elif object.type == PDF_ELEMENT_INDIRECT_OBJECT:
                writer.writeObject(object)

            # Handle printing to console
            if object.type == PDF_ELEMENT_COMMENT:
                print('PDF Comment %s' % runner.FormatOutput(object.comment, self.options.raw))
                print('')

            elif object.type == PDF_ELEMENT_XREF and self.selectXref:
                if self.options.debug:
                    print('xref %s' % runner.FormatOutput(object.content, self.options.raw))
                else:
                    print('xref')
                print('')

            elif object.type == PDF_ELEMENT_TRAILER and self.selectTrailer:
                oPDFParseDictionary = runner.cPDFParseDictionary(object.content[1:], self.options.nocanonicalizedoutput)
                if oPDFParseDictionary == None:
                    print('trailer %s' % runner.FormatOutput(object.content, self.options.raw))
                else:
                    print('trailer')
                    oPDFParseDictionary.PrettyPrint('  ')
                print('')
                    
            elif object.type == PDF_ELEMENT_STARTXREF and self.selectStartXref:
                print('startxref %d' % object.index)
                print('')

            elif object.type == PDF_ELEMENT_INDIRECT_OBJECT and self.selectIndirectObject:
                if runner.EqualCanonical(object.GetType(), "/Font"):
                    runner.PrintObject(object, self.options)
                # else:
                #     runner.PrintObject(object, self.options)

            # elif object.type == PDF_ELEMENT_MALFORMED:
            #     try:
            #         fExtract = open(self.options.extract, 'wb')
            #         try:
            #             fExtract.write(C2BIP3(object.content))
            #         except:
            #             print('Error writing file %s' % self.options.extract)
            #         fExtract.close()
            #     except:
            #         print('Error writing file %s' % self.options.extract)

        with open('EmptyToUnicode.txt', 'r') as f:
            emptyToUnicode = f.read()
            writer.writeIndirectObject(524, 0, emptyToUnicode)
            
        writer.writeXrefAndTrailer(' '.join(savedRoot))

        # if self.options.generate or self.options.generateembedded != 0:
        #     print("    oPDF.xrefAndTrailer('%s')" % ' '.join(savedRoot))
        #     print('')
        #     print("if __name__ == '__main__':")
        #     print('    Main()')
